<!DOCTYPE html>

<html>
<head>
  <title>delorean.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="delorean.html">
                delorean.js
              </a>
            
              
              <a class="source" href="requirements.html">
                requirements.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>delorean.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DeLorean</span>) </span>{
<span class="hljs-pi">  'use strict'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>There are two main concepts in Flux structure: <strong>Dispatchers</strong> and <strong>Stores</strong>.
Action Creators are simply helpers but doesn’t require any framework level
abstraction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> Dispatcher, Store;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2 id="private-helper-functions">Private Helper Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Helper functions are private functions to be used in codebase.
It’s better using two underscore at the beginning of the function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-comment">/* `__hasOwn` function is a shortcut for `Object#hasOwnProperty` */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__hasOwn</span>(<span class="hljs-params">object, prop</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(object, prop);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Use <code>__generateActionName</code> function to generate action names.
E.g. If you create an action with name <code>hello</code> it will be
<code>action:hello</code> for the Flux.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__generateActionName</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'action:'</span> + name;
  }

  <span class="hljs-comment">/* It's used by the schemes to save the original version (not calculated)
     of the data. */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__generateOriginalName</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'original:'</span> + name;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p><code>__findDispatcher</code> is a private function for <strong>React components</strong>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__findDispatcher</span>(<span class="hljs-params">view</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Provide a useful error message if no dispatcher is found</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (DeLorean.dispatcher == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-string">'No dispatcher found. The DeLoreanJS mixin requires a "dispatcher" has been created using Flux.createDispatcher.'</span>;
    }
    <span class="hljs-keyword">return</span> DeLorean.dispatcher;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p><code>__clone</code> creates a deep copy of an object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__clone</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">'object'</span>) { <span class="hljs-keyword">return</span> obj; }
    <span class="hljs-keyword">var</span> copy = obj.constructor();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> attr <span class="hljs-keyword">in</span> obj) {
      <span class="hljs-keyword">if</span> (__hasOwn(obj, attr)) {
        copy[attr] = __clone(obj[attr]);
      }
    }
    <span class="hljs-keyword">return</span> copy;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p><code>__extend</code> adds props to obj</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__extend</span>(<span class="hljs-params">obj, props</span>) </span>{
    props = __clone(props);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> props) {
      <span class="hljs-keyword">if</span> (props.hasOwnProperty(prop)) {
        obj[prop] = props[prop];
      }
    }
    <span class="hljs-keyword">return</span> obj;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h2 id="dispatcher">Dispatcher</h2>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>The dispatcher is <strong>the central hub</strong> that <strong>manages all data flow</strong> in
a Flux application. It is essentially a <em>registry of callbacks into the
stores</em>. Each store registers itself and provides a callback. When the
dispatcher responds to an action, all stores in the application are sent
the data payload provided by the action via the callbacks in the registry.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Dispatcher = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h3 id="dispatcher-helpers">Dispatcher Helpers</h3>

            </div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Rollback listener adds a <code>rollback</code> event listener to the bunch of
stores.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__rollbackListener</span>(<span class="hljs-params">stores</span>) </span>{

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__listener</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> stores) {
          stores[i].listener.emit(<span class="hljs-string">'__rollback'</span>);
        }
      }

      <span class="hljs-comment">/* If any of them fires `rollback` event, all of the stores
         will be emitted to be rolled back with `__rollback` event. */</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j <span class="hljs-keyword">in</span> stores) {
        stores[j].listener.on(<span class="hljs-string">'rollback'</span>, __listener);
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h3 id="dispatcher-prototype">Dispatcher Prototype</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dispatcher</span>(<span class="hljs-params">stores</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p><code>DeLorean.EventEmitter</code> is <code>require(&#39;events&#39;).EventEmitter</code> by default.
you can change it using <code>DeLorean.Flux.define(&#39;EventEmitter&#39;, AnotherEventEmitter)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      DeLorean.EventEmitter.defaultMaxListeners = <span class="hljs-number">100</span>;
      <span class="hljs-keyword">this</span>.listener = <span class="hljs-keyword">new</span> DeLorean.EventEmitter();
      <span class="hljs-keyword">this</span>.stores = stores;

      <span class="hljs-comment">/* Stores should be listened for rollback events. */</span>
      __rollbackListener(<span class="hljs-built_in">Object</span>.keys(stores).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
        <span class="hljs-keyword">return</span> stores[key];
      }));
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p><code>dispatch</code> method dispatch the event with <code>data</code> (or <strong>payload</strong>)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Dispatcher.prototype.dispatch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, stores, deferred, args;
      args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);

      <span class="hljs-keyword">this</span>.listener.emit.apply(<span class="hljs-keyword">this</span>.listener, [<span class="hljs-string">'dispatch'</span>].concat(args));

      <span class="hljs-comment">/* Stores are key-value pairs. Collect store instances into an array. */</span>
      stores = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> stores = [], store;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> storeName <span class="hljs-keyword">in</span> self.stores) {
          store = self.stores[storeName];
          <span class="hljs-comment">/* Store value must be an _instance of Store_. */</span>
          <span class="hljs-keyword">if</span> (!store <span class="hljs-keyword">instanceof</span> Store) {
            <span class="hljs-keyword">throw</span> <span class="hljs-string">'Given store is not a store instance'</span>;
          }
          stores.push(store);
        }
        <span class="hljs-keyword">return</span> stores;
      }());</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Store instances should wait for finish. So you can know if all the
stores are dispatched properly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      deferred = <span class="hljs-keyword">this</span>.waitFor(stores, args[<span class="hljs-number">0</span>]);

      <span class="hljs-comment">/* Payload should send to all related stores. */</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> storeName <span class="hljs-keyword">in</span> self.stores) {
        self.stores[storeName].dispatchAction.apply(self.stores[storeName], args);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p><code>dispatch</code> returns deferred object you can just use <strong>promise</strong>
for dispatching: <code>dispatch(..).then(..)</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> deferred;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p><code>waitFor</code> is actually a <em>semi-private</em> method. Because it’s kind of internal
and you don’t need to call it from outside most of the times. It takes
array of store instances (<code>[Store, Store, Store, ...]</code>). It will create
a promise and return it. <em>Whenever store changes, it resolves the promise</em>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Dispatcher.prototype.waitFor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">stores, actionName</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, promises;
      promises = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> __promises = [], promise;

        <span class="hljs-comment">/* `__promiseGenerator` generates a simple promise that resolves itself when
            related store is changed. */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__promiseGenerator</span>(<span class="hljs-params">store</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p><code>DeLorean.Promise</code> is <code>require(&#39;es6-promise&#39;).Promise</code> by default.
you can change it using <code>DeLorean.Flux.define(&#39;Promise&#39;, AnotherPromise)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DeLorean.Promise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
            store.listener.once(<span class="hljs-string">'change'</span>, resolve);
          });
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> stores) {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Only generate promises for stores that ae listening for this action</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (stores[i].actions &amp;&amp; stores[i].actions[actionName] != <span class="hljs-literal">null</span>) {
            promise = __promiseGenerator(stores[i]);
            __promises.push(promise);
          }
        }
        <span class="hljs-keyword">return</span> __promises;
      }());</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>When all the promises are resolved, dispatcher emits <code>change:all</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> DeLorean.Promise.all(promises).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        self.listener.emit(<span class="hljs-string">'change:all'</span>);
      });
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p><code>registerAction</code> method adds a method to the prototype. So you can just use
<code>dispatcherInstance.actionName()</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Dispatcher.prototype.registerAction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, callback</span>) </span>{
      <span class="hljs-comment">/* The callback must be a function. */</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">this</span>[action] = callback.bind(<span class="hljs-keyword">this</span>.stores);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-string">'Action callback should be a function.'</span>;
      }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p><code>register</code> method adds an global action callback to the dispatcher.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Dispatcher.prototype.register = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
      <span class="hljs-comment">/* The callback must be a function. */</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">this</span>.listener.on(<span class="hljs-string">'dispatch'</span>, callback);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-string">'Global callback should be a function.'</span>;
      }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p><code>getStore</code> returns the store from stores hash.
You can also use <code>dispatcherInstance.stores[storeName]</code> but
it checks if the store really exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Dispatcher.prototype.getStore = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">storeName</span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stores[storeName]) {
        <span class="hljs-keyword">throw</span> <span class="hljs-string">'Store '</span> + storeName + <span class="hljs-string">' does not exist.'</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stores[storeName].getState();
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <h3 id="shortcuts">Shortcuts</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    Dispatcher.prototype.on = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.listener.on.apply(<span class="hljs-keyword">this</span>.listener, <span class="hljs-built_in">arguments</span>);
    };

    Dispatcher.prototype.off = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.listener.removeListener.apply(<span class="hljs-keyword">this</span>.listener, <span class="hljs-built_in">arguments</span>);
    };

    Dispatcher.prototype.emit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.listener.emit.apply(<span class="hljs-keyword">this</span>.listener, <span class="hljs-built_in">arguments</span>);
    };

    <span class="hljs-keyword">return</span> Dispatcher;
  }());</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h2 id="store">Store</h2>

            </div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Stores contain the application state and logic. Their role is somewhat similar
to a model in a traditional MVC, but they manage the state of many objects.
Unlike MVC models, they are not instances of one object, nor are they the
same as Backbone’s collections. More than simply managing a collection of
ORM-style objects, stores manage the application state for a particular
domain within the application.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Store = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h3 id="store-prototype">Store Prototype</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Store</span>(<span class="hljs-params">args</span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state) {
        <span class="hljs-keyword">this</span>.state = {};
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p><code>DeLorean.EventEmitter</code> is <code>require(&#39;events&#39;).EventEmitter</code> by default.
you can change it using <code>DeLorean.Flux.define(&#39;EventEmitter&#39;, AnotherEventEmitter)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.listener = <span class="hljs-keyword">new</span> DeLorean.EventEmitter();
      <span class="hljs-keyword">this</span>.bindActions();
      <span class="hljs-keyword">this</span>.buildScheme();

      <span class="hljs-keyword">this</span>.initialize.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    Store.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    };

    Store.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state[arg];
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p><code>set</code> method updates the data defined at the <code>scheme</code> of the store.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.set = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg1, value</span>) </span>{
      <span class="hljs-keyword">var</span> changedProps = [];
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg1 === <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> keyName <span class="hljs-keyword">in</span> arg1) {
          changedProps.push(keyName);
          <span class="hljs-keyword">this</span>.setValue(keyName, arg1[keyName]);
        }
      } <span class="hljs-keyword">else</span> {
        changedProps.push(arg1);
        <span class="hljs-keyword">this</span>.setValue(arg1, value);
      }
      <span class="hljs-keyword">this</span>.recalculate(changedProps);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state[arg1];
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><code>set</code> method updates the data defined at the <code>scheme</code> of the store.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.setValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>{
      <span class="hljs-keyword">var</span> scheme = <span class="hljs-keyword">this</span>.scheme, definition;
      <span class="hljs-keyword">if</span> (scheme &amp;&amp; <span class="hljs-keyword">this</span>.scheme[key]) {
        definition = scheme[key];</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>This will allow you to directly set falsy values before falling back to the definition default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>.state[key] = (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'undefined'</span>) ? value : definition.default;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> definition.calculate === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">this</span>.state[__generateOriginalName(key)] = value;
          <span class="hljs-keyword">this</span>.state[key] = definition.calculate.call(<span class="hljs-keyword">this</span>, value);
        }
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Scheme <strong>must</strong> include the key you wanted to set.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">console</span> != <span class="hljs-literal">null</span>) {
          <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'Scheme must include the key, '</span> + key + <span class="hljs-string">', you are trying to set. '</span> + key + <span class="hljs-string">' will NOT be set on the store.'</span>);
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state[key];
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Removes the scheme format and standardizes all the shortcuts.
If you run <code>formatScheme({name: &#39;joe&#39;})</code> it will return you
<code>{name: {default: &#39;joe&#39;}}</code>. Also if you run <code>formatScheme({fullname: function () {}})</code>
it will return <code>{fullname: {calculate: function () {}}}</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.formatScheme = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scheme</span>) </span>{
      <span class="hljs-keyword">var</span> formattedScheme = {}, definition, defaultValue, calculatedValue;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> keyName <span class="hljs-keyword">in</span> scheme) {
        definition = scheme[keyName];
        defaultValue = <span class="hljs-literal">null</span>;
        calculatedValue = <span class="hljs-literal">null</span>;

        formattedScheme[keyName] = {<span class="hljs-keyword">default</span>: <span class="hljs-literal">null</span>};

        <span class="hljs-comment">/* {key: 'value'} will be {key: {default: 'value'}} */</span>
        defaultValue = (definition &amp;&amp; <span class="hljs-keyword">typeof</span> definition === <span class="hljs-string">'object'</span>) ?
                        definition.default : definition;
        formattedScheme[keyName].default = defaultValue;

        <span class="hljs-comment">/* {key: function () {}} will be {key: {calculate: function () {}}} */</span>
        <span class="hljs-keyword">if</span> (definition &amp;&amp; <span class="hljs-keyword">typeof</span> definition.calculate === <span class="hljs-string">'function'</span>) {
          calculatedValue = definition.calculate;
          <span class="hljs-comment">/* Put a dependency array on formattedSchemes with calculate defined */</span>
          <span class="hljs-keyword">if</span> (definition.deps) {
            formattedScheme[keyName].deps = definition.deps;
          } <span class="hljs-keyword">else</span> {
            formattedScheme[keyName].deps = [];
          }

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> definition === <span class="hljs-string">'function'</span>) {
          calculatedValue = definition;
        }
        <span class="hljs-keyword">if</span> (calculatedValue) {
          formattedScheme[keyName].calculate = calculatedValue;
        }
      }
      <span class="hljs-keyword">return</span> formattedScheme;
    };

    <span class="hljs-comment">/* Applying `scheme` to the store if exists. */</span>
    Store.prototype.buildScheme = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> scheme, calculatedData, keyName, definition, dependencyMap, dependents, dep, changedProps = [];

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.scheme === <span class="hljs-string">'object'</span>) {
        <span class="hljs-comment">/* Scheme must be formatted to standardize the keys. */</span>
        scheme = <span class="hljs-keyword">this</span>.scheme = <span class="hljs-keyword">this</span>.formatScheme(<span class="hljs-keyword">this</span>.scheme);
        dependencyMap = <span class="hljs-keyword">this</span>.__dependencyMap = {};

        <span class="hljs-comment">/* Set the defaults first */</span>
        <span class="hljs-keyword">for</span> (keyName <span class="hljs-keyword">in</span> scheme) {
          definition = scheme[keyName];
          <span class="hljs-keyword">this</span>.state[keyName] = __clone(definition.default);
        }

        <span class="hljs-comment">/* Set the calculations */</span>
        <span class="hljs-keyword">for</span> (keyName <span class="hljs-keyword">in</span> scheme) {
          definition = scheme[keyName];
          <span class="hljs-keyword">if</span> (definition.calculate) {</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Create a dependency map - {keyName: [arrayOfKeysThatDependOnIt]}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            dependents = definition.deps || [];

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; dependents.length; i++) {
              dep = dependents[i];
              <span class="hljs-keyword">if</span> (dependencyMap[dep] == <span class="hljs-literal">null</span>) {
                dependencyMap[dep] = [];
              }
              dependencyMap[dep].push(keyName);
            }

            <span class="hljs-keyword">this</span>.state[__generateOriginalName(keyName)] = definition.default;
            <span class="hljs-keyword">this</span>.state[keyName] = definition.calculate.call(<span class="hljs-keyword">this</span>, definition.default);
            changedProps.push(keyName);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Recalculate any properties dependent on those that were just set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>.recalculate(changedProps);
      }
    };

    Store.prototype.recalculate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">changedProps</span>) </span>{
      <span class="hljs-keyword">var</span> scheme = <span class="hljs-keyword">this</span>.scheme, dependencyMap = <span class="hljs-keyword">this</span>.__dependencyMap, didRun = [], definition, keyName, dependents, dep;</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Only iterate over the properties that just changed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; changedProps.length; i++) {
        dependents = dependencyMap[changedProps[i]];</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>If there are no properties dependent on this property, do nothing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (dependents == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">continue</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Iterate over the dependendent properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> d = <span class="hljs-number">0</span>; d &lt; dependents.length; d++) {
          dep = dependents[d];</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Do nothing if this value has already been recalculated on this change batch</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (didRun.indexOf(dep) !== -<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">continue</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Calculate this value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          definition = scheme[dep];
          <span class="hljs-keyword">this</span>.state[dep] = definition.calculate.call(<span class="hljs-keyword">this</span>,
                            <span class="hljs-keyword">this</span>.state[__generateOriginalName(dep)] || definition.default);</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Make sure this does not get calculated again in this change batch</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          didRun.push(dep);
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Update Any deps on the deps</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (didRun.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>.recalculate(didRun);
      }
      <span class="hljs-keyword">this</span>.listener.emit(<span class="hljs-string">'change'</span>);
    };

    Store.prototype.getState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state;
    };

    Store.prototype.clearState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.state = {};
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };

    Store.prototype.resetState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.buildScheme();
      <span class="hljs-keyword">this</span>.listener.emit(<span class="hljs-string">'change'</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Stores must have a <code>actions</code> hash of <code>actionName: methodName</code>
<code>methodName</code> is the <code>this.store</code>‘s prototype method..</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.bindActions = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> callback;

      <span class="hljs-keyword">this</span>.emitChange = <span class="hljs-keyword">this</span>.listener.emit.bind(<span class="hljs-keyword">this</span>.listener, <span class="hljs-string">'change'</span>);
      <span class="hljs-keyword">this</span>.emitRollback = <span class="hljs-keyword">this</span>.listener.emit.bind(<span class="hljs-keyword">this</span>.listener, <span class="hljs-string">'rollback'</span>);
      <span class="hljs-keyword">this</span>.rollback = <span class="hljs-keyword">this</span>.listener.on.bind(<span class="hljs-keyword">this</span>.listener, <span class="hljs-string">'__rollback'</span>);
      <span class="hljs-keyword">this</span>.emit = <span class="hljs-keyword">this</span>.listener.emit.bind(<span class="hljs-keyword">this</span>.listener);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> actionName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.actions) {
        <span class="hljs-keyword">if</span> (__hasOwn(<span class="hljs-keyword">this</span>.actions, actionName)) {
          callback = <span class="hljs-keyword">this</span>.actions[actionName];
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>[callback] !== <span class="hljs-string">'function'</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-string">'Callback \''</span> + callback + <span class="hljs-string">'\' defined for action \''</span> + actionName + <span class="hljs-string">'\' should be a method defined on the store!'</span>;
          }
          <span class="hljs-comment">/* And `actionName` should be a name generated by `__generateActionName` */</span>
          <span class="hljs-keyword">this</span>.listener.on(__generateActionName(actionName), <span class="hljs-keyword">this</span>[callback].bind(<span class="hljs-keyword">this</span>));
        }
      }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p><code>dispatchAction</code> called from a dispatcher. You can also call anywhere but
you probably won’t need to do. It simply <strong>emits an event with a payload</strong>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.dispatchAction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">actionName, data</span>) </span>{
      <span class="hljs-keyword">this</span>.listener.emit(__generateActionName(actionName), data);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <h3 id="shortcuts">Shortcuts</h3>

            </div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p><code>listenChanges</code> is a shortcut for <code>Object.observe</code> usage. You can just use
<code>Object.observe(object, function () { ... })</code> but everytime you use it you
repeat yourself. DeLorean has a shortcut doing this properly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.listenChanges = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">object</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, observer;
      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.observe) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Store#listenChanges method uses Object.observe, you should fire changes manually.'</span>);
        <span class="hljs-keyword">return</span>;
      }

      observer = <span class="hljs-built_in">Array</span>.isArray(object) ? <span class="hljs-built_in">Array</span>.observe : <span class="hljs-built_in">Object</span>.observe;

      observer(object, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">changes</span>) </span>{
        self.listener.emit(<span class="hljs-string">'change'</span>, changes);
      });
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p><code>onChange</code> simply listens changes and calls a callback. Shortcut for
a <code>on(&#39;change&#39;)</code> command.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.onChange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
      <span class="hljs-keyword">this</span>.listener.on(<span class="hljs-string">'change'</span>, callback);
    };

    <span class="hljs-keyword">return</span> Store;
  }());</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <h3 id="flux-wrapper">Flux Wrapper</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  DeLorean.Flux = {</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p><code>createStore</code> generates a store based on the definition</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    createStore: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
      <span class="hljs-comment">/* store parameter must be an `object` */</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> definition !== <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-string">'Stores should be defined by passing the definition to the constructor'</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>extends the store with the definition attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> Child = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> Store.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>); };
      <span class="hljs-keyword">var</span> Surrogate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>.constructor = Child; };
      Surrogate.prototype = Store.prototype;
      Child.prototype = <span class="hljs-keyword">new</span> Surrogate();

      __extend(Child.prototype, definition);

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Child();
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p><code>createDispatcher</code> generates a dispatcher with actions to dispatch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* `actionsToDispatch` should be an object. */</span>
    createDispatcher: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">actionsToDispatch</span>) </span>{
      <span class="hljs-keyword">var</span> actionsOfStores, dispatcher, callback, triggers, triggerMethod;</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>If it has <code>getStores</code> method it should be get and pass to the <code>Dispatcher</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> actionsToDispatch.getStores === <span class="hljs-string">'function'</span>) {
        actionsOfStores = actionsToDispatch.getStores();
      }

      <span class="hljs-comment">/* If there are no stores defined, it's an empty object. */</span>
      dispatcher = <span class="hljs-keyword">new</span> Dispatcher(actionsOfStores || {});

      <span class="hljs-comment">/* Now call `registerAction` method for every action. */</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> actionName <span class="hljs-keyword">in</span> actionsToDispatch) {
        <span class="hljs-keyword">if</span> (__hasOwn(actionsToDispatch, actionName)) {
          <span class="hljs-comment">/* `getStores` &amp; `viewTriggers` are special properties, it's not an action. Also an extra check to make sure we're binding to a function */</span>
          <span class="hljs-keyword">if</span> (actionName !== <span class="hljs-string">'getStores'</span> &amp;&amp; actionName !== <span class="hljs-string">'viewTriggers'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> actionsToDispatch[actionName] === <span class="hljs-string">'function'</span>) {
            callback = actionsToDispatch[actionName];
            dispatcher.registerAction(actionName, callback.bind(dispatcher));
          }
        }
      }

      <span class="hljs-comment">/* Bind triggers */</span>
      triggers = actionsToDispatch.viewTriggers;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> triggerName <span class="hljs-keyword">in</span> triggers) {
        triggerMethod = triggers[triggerName];
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> dispatcher[triggerMethod] === <span class="hljs-string">'function'</span>) {
          dispatcher.on(triggerName, dispatcher[triggerMethod]);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">console</span> != <span class="hljs-literal">null</span>) {
            <span class="hljs-built_in">console</span>.warn(triggerMethod + <span class="hljs-string">' should be a method defined on your dispatcher. The '</span> + triggerName + <span class="hljs-string">' trigger will not be bound to any method.'</span>);
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Allow only a single dispatcher</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (DeLorean.dispatcher != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">console</span> != <span class="hljs-literal">null</span>) {
          <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'You are attempting to create more than one dispatcher. DeLorean is intended to be used with a single dispatcher. This latest dispatcher created will overwrite any previous versions.'</span>);
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Create an internal reference to the dispathcer instance. This allows it to be found by the mixins.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      DeLorean.dispatcher = dispatcher;

      <span class="hljs-keyword">return</span> dispatcher;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <h3 id="-delorean-flux-define-"><code>DeLorean.Flux.define</code></h3>
<p>It’s a key to <em>hack</em> DeLorean easily. You can just inject something
you want to define.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    define: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>{
      DeLorean[key] = value;
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Store and Dispatcher are the only base classes of DeLorean.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  DeLorean.Dispatcher = Dispatcher;
  DeLorean.Store = Store;</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <h2 id="built-in-react-mixin">Built-in React Mixin</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  DeLorean.Flux.mixins = {</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>It should be inserted to the React components which
used in Flux.
Simply <code>mixin: [Flux.mixins.storeListener]</code> will work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    storeListener: {

      trigger: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.__dispatcher.emit.apply(<span class="hljs-keyword">this</span>.__dispatcher, <span class="hljs-built_in">arguments</span>);
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>After the component mounted, listen changes of the related stores</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      componentDidMount: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, store, storeName;

        <span class="hljs-comment">/* `__changeHandler` is a **listener generator** to pass to the `onChange` function. */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__changeHandler</span>(<span class="hljs-params">store, storeName</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> state, args;
            <span class="hljs-comment">/* If the component is mounted, change state. */</span>
            <span class="hljs-keyword">if</span> (self.isMounted()) {
              self.setState(self.getStoreStates());
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>When something changes it calls the components <code>storeDidChanged</code> method if exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (self.storeDidChange) {
              args = [storeName].concat(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>));
              self.storeDidChange.apply(self, args);
            }
          };
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Remember the change handlers so they can be removed later</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>.__changeHandlers = {};

        <span class="hljs-comment">/* Generate and bind the change handlers to the stores. */</span>
        <span class="hljs-keyword">for</span> (storeName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.__watchStores) {
          <span class="hljs-keyword">if</span> (__hasOwn(<span class="hljs-keyword">this</span>.stores, storeName)) {
            store = <span class="hljs-keyword">this</span>.stores[storeName];
            <span class="hljs-keyword">this</span>.__changeHandlers[storeName] = __changeHandler(store, storeName);
            store.onChange(<span class="hljs-keyword">this</span>.__changeHandlers[storeName]);
          }
        }
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>When a component unmounted, it should stop listening.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      componentWillUnmount: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> storeName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.__changeHandlers) {
          <span class="hljs-keyword">if</span> (__hasOwn(<span class="hljs-keyword">this</span>.stores, storeName)) {
            <span class="hljs-keyword">var</span> store = <span class="hljs-keyword">this</span>.stores[storeName];
            store.listener.removeListener(<span class="hljs-string">'change'</span>, <span class="hljs-keyword">this</span>.__changeHandlers[storeName]);
          }
        }
      },

      getInitialState: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, state, storeName;

        <span class="hljs-comment">/* The dispatcher should be easy to access and it should use `__findDispatcher`
           method to find the parent dispatchers. */</span>
        <span class="hljs-keyword">this</span>.__dispatcher = __findDispatcher(<span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>If <code>storesDidChange</code> method presents, it’ll be called after all the stores
were changed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.storesDidChange) {
          <span class="hljs-keyword">this</span>.__dispatcher.on(<span class="hljs-string">'change:all'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.storesDidChange();
          });
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Since <code>dispatcher.stores</code> is harder to write, there’s a shortcut for it.
You can use <code>this.stores</code> from the React component.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>.stores = <span class="hljs-keyword">this</span>.__dispatcher.stores;

        <span class="hljs-keyword">this</span>.__watchStores = {};
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.watchStores != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.watchStores.length;  i++) {
            storeName = <span class="hljs-keyword">this</span>.watchStores[i];
            <span class="hljs-keyword">this</span>.__watchStores[storeName] = <span class="hljs-keyword">this</span>.stores[storeName];
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">this</span>.__watchStores = <span class="hljs-keyword">this</span>.stores;
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">console</span> != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">Object</span>.keys != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.stores).length &gt; <span class="hljs-number">4</span>) {
            <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'Your component is watching changes on all stores, you may want to define a "watchStores" property in order to only watch stores relevant to this component.'</span>);
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getStoreStates();
      },

      getStoreStates: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> state = {stores: {}}, store;

        <span class="hljs-comment">/* Set `state.stores` for all present stores with a `setState` method defined. */</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> storeName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.__watchStores) {
          <span class="hljs-keyword">if</span> (__hasOwn(<span class="hljs-keyword">this</span>.stores, storeName)) {
            state.stores[storeName] = <span class="hljs-keyword">this</span>.__watchStores[storeName].getState();
          }
        }
        <span class="hljs-keyword">return</span> state;
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p><code>getStore</code> is a shortcut to get the store from the state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      getStore: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">storeName</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">console</span> != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.__watchStores[storeName] === <span class="hljs-string">'undefined'</span>) {
          <span class="hljs-keyword">var</span> message;
          message = <span class="hljs-string">'Attempt to getStore '</span> + storeName + <span class="hljs-string">' failed. '</span>;
          message += <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.stores[storeName] === <span class="hljs-string">'undefined'</span> ? <span class="hljs-string">'It is not defined on the dispatcher. '</span> : <span class="hljs-string">'It is not being watched by the component. '</span>;
          message += <span class="hljs-keyword">this</span>.constructor != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.constructor.displayName != <span class="hljs-literal">null</span> ? <span class="hljs-string">'Check the '</span> + <span class="hljs-keyword">this</span>.constructor.displayName + <span class="hljs-string">' component.'</span> : <span class="hljs-string">''</span>;
          <span class="hljs-built_in">console</span>.warn(message);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.stores[storeName];
      }
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <h2 id="delorean-api">DeLorean API</h2>
<p>DeLorean can be used in <strong>CommonJS</strong> projects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span>.exports !== <span class="hljs-string">'undefined'</span>) {

    <span class="hljs-keyword">var</span> requirements = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./requirements'</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> requirement <span class="hljs-keyword">in</span> requirements) {
      DeLorean.Flux.define(requirement, requirements[requirement]);
    }
    <span class="hljs-built_in">module</span>.exports = DeLorean;</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>It can be also used in <strong>AMD</strong> projects, too.
And if there is no module system initialized, just pass the DeLorean
to the <code>window</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) {
      define([<span class="hljs-string">'./requirements.js'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Import Modules in require.js pattern</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> requirement <span class="hljs-keyword">in</span> requirements) {
          DeLorean.Flux.define(requirement, requirements[requirement]);
        }

        <span class="hljs-keyword">return</span> DeLorean;
      });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">window</span>.DeLorean = DeLorean;
    }
  }

})({});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
